<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[The Flatiron Experience]]></title>
  <link href="http://mbukantz.github.io/atom.xml" rel="self"/>
  <link href="http://mbukantz.github.io/"/>
  <updated>2015-10-26T22:06:52-04:00</updated>
  <id>http://mbukantz.github.io/</id>
  <author>
    <name><![CDATA[Michael Bukantz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Blocks, Procs, and Lambdas... oh my!]]></title>
    <link href="http://mbukantz.github.io/blog/2015/10/25/blocksprocsandlamdas/"/>
    <updated>2015-10-25T16:01:21-04:00</updated>
    <id>http://mbukantz.github.io/blog/2015/10/25/blocksprocsandlamdas</id>
    <content type="html"><![CDATA[<p>Before I enrolled in the Flatiron School, my introduction to programming was through websites like Codecademy and Ruby Monk.  I was doing whatever I could to scrape the surface of coding while trying to entertain myself through the endless boredom of my job.  Two of the topics that were heavily reinforced on Ruby Monk were Procs and Lambdas.  While I found traditional blocks to be intuitive and straightforward, I found Procs and Lambdas to be confusing and abstract.  I was surprised to find out through our first four weeks at the Flatiron School that neither were mentioned in detail.  I did see a few Procs in different rspec tests, but it was not imperative to understand the inner workings of them.</p>




<p>With four weeks of experience under my belt, I wanted to go back and investigate blocks, Procs, and Lambdas, three <em>'closures'</em> in Ruby.</p>


<p></p>

<h3>Procs as Objects versus Blocks</h3>




<p>While blocks are syntactically straightforward, they sometimes are guilty of violating DRY (Don't Repeat Yourself!).  This is where Procs come into the picture.  Short for Procedures, a Proc is a reusable block.  In addition, a Proc is an object, therefore it can be saved as a variable.  To make this as simple as possible, a block is technically a Proc that cannot be saved or reused.  A block is a stripped-down and temporary version of a Proc.  Let's take a look at an example of how a Proc can behave:</p>


<p><img src="../images/Proc_screenshot.png"></p>

<p>In the screenshot above, we are given an array.  Next, we set a variable proc equal to a new Proc <b>object</b> that passes a block that will multiply x by 2.  After setting the proc variable to the object, we map the array to the proc.  The output, as we would expect, is an array of x*2 values.</p>




<p>Procs can also be "called" on with arguments from the block.  Here is a snapshot of what I mean: </p>


<p><img src="../images/Proc_call.png"></p>

<p>So, what would be an example of when you would need to use a Proc?  This would usually occur when you need to call back multiple values within a method.  This is best demonstrated in another example.  Below, there is a method call_twice that takes an argument of a hash of "procs".  First, we call the :first_key('s) value of the procs hash. Next we puts out "sunk your".  Last, we call the :last_key('s) value of the procs hash.  When we pass a hash with Proc values into the call_twice method, we get the output we desire:</p>




<p>To summarize when to use Procs over blocks, there are two main reasons:</p>




<ol>
  <li>You want to reuse a block of code multiple times.</li>
  <li>The method that you are in will have more than one call back.</li>
</ol>




<h3>Procs versus Lambdas</h3>




<p>Lastly, I wanted to touch on the topic of Lambdas.  On the surface, Lamdas appear to behave identically to Procs.  In fact, Lambdas are members of the Proc class.  However, there are two subtle differences.</p>




<ol>
  <li>Lambdas check the number of arguments, while Procs do not.  In the example below, we have set lam equal to a Lambda that puts out the argument passed to it.  When we call the Lambda with one argument, it appropriately outputs the value.  However, when we call the Lambda with 0 or 3 arguments, the Lambda errors out.  This is not demonstrated by Procs, which do not care if they are passed the wrong number of arguments.</li><br>

  <img src="../images/lambda_args.png">

  <img src="../images/proc_args.png"><br><br>

  <li>Lambdas and Procs treat the 'return' keyword differently.  When the 'return' keyword is inside of a Lambda, it will trigger the code right outside of the Lambda code.  When the 'return' keyword is inside of a proc, it triggers the code outside of the <b>method</b>.  Here is an example of the difference:</li>
</ol>


<p><img src="../images/lambdaprocreturn.png"></p>

<p>In this post, we have taken a look at Procs versus blocks and Procs versus Lambdas.  Procs are used instead of Blocks when you want to reuse a portion of code or your method will have more than one call back value.  Lambdas are the same as Procs except for two subtle differences discussed above.  I hope you now have some <em>'closure'</em>.</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unary Operators In Ruby]]></title>
    <link href="http://mbukantz.github.io/blog/2015/10/10/unary-operators-in-ruby/"/>
    <updated>2015-10-10T00:00:00-04:00</updated>
    <id>http://mbukantz.github.io/blog/2015/10/10/unary-operators-in-ruby</id>
    <content type="html"><![CDATA[<p>As I begin the third week in the Flatiron School&rsquo;s immersive web program, I wanted to write about operators in Ruby.  I will focus mainly on unary operators in this post, so let me count down from 3&hellip;2&hellip;1!</p>

<p>There is only one ternary operator in Ruby, which is a conditional expression (if/else) pared down to one line.  Ruby, as a language, is always looking to simplify the syntax of its code and allow us to build clean, concise code.  Here is a snapshot of how a ternary operator behaves:</p>

<center><img src="../images/ternary_screenshot.png"></center>


<p>Next, I&rsquo;ll briefly touch on binary operators.  There are many instances where syntactic sugar in Ruby displays cleaner code at the expense of new programmers understanding what is truly happening.  The most simplistic representation of a binary operator would be addition.  When addition is displayed in Ruby, it appears as &ldquo;a + b&rdquo;.  However, it is actually calling the &ldquo;+&rdquo; method on b, or a.+(b).  &ldquo;a&rdquo; and &ldquo;b&rdquo; represent the two parties in the binary operator.</p>

<center><img src="../images/binary_screenshot.png"></center>


<p>Now, let&rsquo;s get to the meat of this discussion: unary operators.  A unary operator is an operator which only takes a single argument in the form of a receiver.  I will first discuss the four unary operators that come up most frequently, and I will also touch on unary operator reassignment.</p>

<p><b>Opposite Operator (!)</b></p>

<p>The opposite operator is used to represent the opposite of whatever it is placed in front of.  For example, !true is equal to false and !false is equal to true.  You can put ! in front of an equal sign to represent &ldquo;not equal to&rdquo;, and you can even place it in front of a method to test equality.  Here is some code in irb to indicate these concepts:</p>

<center><img src="../images/negative_operator.png"></center>


<p><b>Positive/Negative Operators (+/-)</b></p>

<p>When a plus or minus sign is placed in front of an Integer or a Float and there is no argument before the sign, it will represent a positive or negative interpretation of the value.  This is different than the addition or subtraction methods which we discussed earlier.</p>

<p><b>The Bitwise Complement (~)</b></p>

<p>The bitwise complement operator is slightly more involved than the previous three operators.  A number is depicted by 8 bits.  For example, the integer 2 is represented by 0000 0010.  When we run the ~2 operator, it inverts all of the 0&rsquo;s and 1&rsquo;s and adds one to the bitwise value.  The resulting bitwise value is 1111 1101.  This represents -3.  If you were to run the ~-3, it would return 2 as the complement.  Here is a snapshot in irb:</p>

<center><img src="../images/bitwise_complement.png"></center>


<p><b><u>Unary Operator Reassignment</u></b></p>

<p>One of the neat things about unary operators is that they are not set in stone.  You are able to leverage the @ sign to reassign the +/- operators and use them however you like.  While this may not be the smartest way to set up a method, as the !, +, and - functionality is often used in code, it is nice to know how to do this.  In the example below, I have created a class &ldquo;ReassignmentString&rdquo; that inherits from the &ldquo;String&rdquo; class.  Within the class, there are 4 methods that will reassign the behavior of a string through upcase, downcase, swapcase, and capitalize:</p>

<center><img src="../images/reassignment.png"></center>


<center><img src="../images/reassignment_output.png"></center>


<p>In conclusion, unary operators are a shorter way to represent control flow.  Instead of having to write if/else statements to depict equality, the ! sign does it for us.  In addition, the + and - signs allow us to seamlessly integrate positive and negatives values into our code.  Lastly, the involved ~ operator allows us to delve into the bitwise values of integers to see the bitwise complement.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Post on Octopress]]></title>
    <link href="http://mbukantz.github.io/blog/2015/09/28/my-first-post-on-octopress/"/>
    <updated>2015-09-28T22:28:06-04:00</updated>
    <id>http://mbukantz.github.io/blog/2015/09/28/my-first-post-on-octopress</id>
    <content type="html"><![CDATA[<p>&ldquo;Hello, World.  Testing&rdquo;</p>
]]></content>
  </entry>
  
</feed>
